import random
import numpy
import math

#Order of execution: StartEach() - production - decomposition - EndEach() - homomorphism/interpretation

#initial turtle's orientation: Head Z+ [0,0,1], Up Y+ [0,1,0], Left X+ [1,0,0]
#to align turtle's Right X- [-1,0,0] to Earth's North [0,1,0], rotate the world by -90degrees around Z+ axis, i.e., roll angle offset -90degrees
#order of rotations: roll first, then pitch
#assumption: young branches and leaves never grow until the trunk height at mature phase (in reality, branches and leaves have been falling off at lower trunk segments before matured tree trunk appears smooth)

#Average tree parameters for:
#generic tree: age=10, trunk_pitch_angle=5.0, trunk_height=3.0, no_first_ord_branches=3, no_second_ord_branches=5, branching_pitch_angle=45.0, branching_roll_angle=30.0, diameter_growth_rate=0.1, annual_no_new_nodes=30.0, avg_internode_length=0.03
#)raintree: age=10, trunk_pitch_angle=2.0, trunk_height=2.205, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.619/10, annual_no_new_nodes=28.5, avg_internode_length=0.0589
#)yellow flame: age=11, trunk_pitch_angle=2.0, trunk_height=2.8497, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.4725/11, annual_no_new_nodes=44.148, avg_internode_length=0.03232
#)khaya: age=10, trunk_pitch_angle=0.0, trunk_height=3.872, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.983/10, annual_no_new_nodes=117.231, avg_internode_length=0.02727
#)sterculia: age=4, trunk_pitch_angle=0.0, trunk_height=4.0356, no_first_ord_branches=3, no_second_ord_branches=3, branching_pitch_angle=35.0, branching_roll_angle=120.0, diameter_growth_rate=0.3139/4, annual_no_new_nodes=47.684, avg_internode_length=0.09425
#)palm:age=15, trunk_pitch_angle=5.0, trunk_height=10.0, no_first_ord_branches=10, no_second_ord_branches=0, branching_pitch_angle=10.0, branching_roll_angle=30.0, diameter_growth_rate=0.30/15, annual_no_new_nodes=7.0, avg_internode_length=0.10
#)hopea:age=30, trunk_pitch_angle=0.0, trunk_height=3.0244, no_first_ord_branches=3, no_second_ord_branches=2, branching_pitch_angle=45.0, branching_roll_angle=120.0, diameter_growth_rate=0.3176/30, annual_no_new_nodes=24.0, avg_internode_length=0.02137
#)mahogany:age=20, trunk_pitch_angle=2.0, trunk_height=3.111, no_first_ord_branches=1, no_second_ord_branches=1, branching_pitch_angle=20.0, branching_roll_angle=45.0, diameter_growth_rate=0.476/20, annual_no_new_nodes=26.182, avg_internode_length=0.02584
#)syzygium grande:age=20, trunk_pitch_angle=1.0, trunk_height=4.0438, no_first_ord_branches=3, no_second_ord_branches=3, branching_pitch_angle=20.0, branching_roll_angle=120.0, diameter_growth_rate=0.499/20, annual_no_new_nodes=11.448, avg_internode_length=0.07248
#)tabebuia rosea:age=8, trunk_pitch_angle=0.0, trunk_height=3.265, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.4037/8, annual_no_new_nodes=39.333, avg_internode_length=0.04753
#)syzygium myrtifolium:age=20, trunk_pitch_angle=0.0, trunk_height=1.174, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=45.0, branching_roll_angle=180.0, diameter_growth_rate=0.10/20, annual_no_new_nodes=12.0, avg_internode_length=0.02358

#---------------Parameters for Optimisation-----------------
#age = 10
#trunk_pitch_angle = 2.0           #pitch down wrt turtle's left, in degrees
#trunk_roll_angle = 0.0            #roll left wrt turtle's head, in degrees
#trunk_height = 2.205              #unit: m, trunk's actual length (regardless of orientation wrt ground) - when the trunk reach this height, it will signal the tree to branch out for the first time
#no_first_ord_branches = 2         #number of first order branches
#no_second_ord_branches = 3        #number of second order branches (assume uniformity)
#branching_pitch_angle = 30.0
#branching_roll_angle = 30.0
#diameter_growth_rate = 0.619/age  #m/year? relative growth rate?
#annual_no_new_nodes = 28.5    #number of new buds per year - note that the data were obtained monthly over an unknown period of time (unknown growth phase in the growth season), so we assume this value is peak growth value and annual_no_new_nodes = 12mth x monthly_no_new_nodes, and hence in case of rhythmic growth on monthly basis, monthly_no_new_nodes = annual_no_new_nodes / 12 and growth curve (0-100% growth) will reduce monthly_no_new_nodes by a proportionate factor
#avg_internode_length = 0.0589    #unit: m
#-----------------------------------------------------------

#------------Species-specific Variables---------------------
determinate_growth = True        #flag of determinate or indeterminate growth for buds
determinate_bud_lifespan = 2     #lifespan of a bud before it abort or transform into flower; trees are either annual(lifespan=1yr), biennial(lifespan=2yrs), or perennial(lifespan>2yrs)
rhythmic_growth = True           #flag of rhythmic or continuous growth
rhythmic_growth_period = 1       #cycle of rhythmic growth every x yrs
phyllotaxis_angle = 90           #unit: degrees, angle between first leaf on an internode and first leaf on later internode along the same stem
branch_length_ratio = 0.8        #ratio of child to parent branch length; from one experiment: 0.666
maximumBranchOrder = 4
leafMaxLength = 0.1              #unit: m
leafOldAge = 0.5                 #the leaf is old at age n years old
leafDieAge = 0.7
leafGrowthRate = 0.6             #the leaf length increases at x meter per year
terminalBranching = False         #flag to allow bud to split into 2 or more to produce dichotomy/polytomy - only applicable to mostly ferns & mosses, not to gymnospermae & angiospermae
delayedBranching = True          #flag to delay branching (dormant axillary bud will be active after a period of time)
branchingDelay = 1               #unit: year
sympodialBranching = False        #true: sympodial, false: monopodial. Mechanism: when apical bud aborts/flowers, nearest lateral bud(s) transition from dormant to active for branching out. Note: sympodial branching is only applicable if determinate_growth is True
#-----------------------------------------------------------

#-----------Common Variables--------------------------------
steps = 12 #int(annual_no_new_nodes)       #timestep: 'steps' steps/year, capped at annual_no_new_nodes. Branching signal relay will delay branching out if steps < annual_no_new_nodes
germination_offset = 3     #number of initial derivation to account for germination (reality: 1-2 weeks) before visual growth of internode starts (i.e., before time t starts)
partial_node_per_step = (float)(annual_no_new_nodes%steps)/steps
no_new_nodes_per_step = int(annual_no_new_nodes // steps)  #integer
derivation_length = germination_offset + age*steps
growthFactor = 1.0
internode_length = avg_internode_length
growthFactorBranchingThreshold = 0.5
growthFactorLeafingThreshold = 0.3
wakeupBudPool = []
idGenerator = 0    #store the latest bud ID. Note: 1 ID per node, hence multiple buds on 1 node will have the same ID
clearPool = False
#-----------------------------------------------------------


def getGrowthFactor():
  t = (float)((getIterationNb()+1-germination_offset) % (steps*rhythmic_growth_period)) / (steps*rhythmic_growth_period)
  growthFactor = 0.25*math.sin(2*math.pi*t) + 0.75      #growth curve equation - always bind the curve value range within [0,1]
  return growthFactor

def StartEach():
  global growthFactor, partial_node_per_step, no_new_nodes_per_step, internode_length, allowBranching, wakeupBudPool
  print 'Derivation progress:', getIterationNb()+1, ' / ', derivation_length
  if rhythmic_growth is True and getIterationNb()+1 > germination_offset:
    growthFactor = getGrowthFactor()
    #print 'growthFactor=', growthFactor
    partial_node_per_step = (float)((growthFactor*annual_no_new_nodes)%steps)/steps
    no_new_nodes_per_step = int((growthFactor*annual_no_new_nodes) // steps)  #integer
    internode_length = growthFactor * avg_internode_length
  if len(wakeupBudPool) > 0:
    print 'wakeupBudPool = ', wakeupBudPool
  if clearPool is True:
    wakeupBudPool = []

def EndEach(lstring):
  #pass
  print 'Current lstring:', lstring


module O    #seed
module S    #shoot
module R    #root
module B    #bud
module G    #growth unit (for rhythmic growth)
module N    #node
module I    #internode
module L    #leaf
module W    #flower
module U    #fruit

Axiom: O

derivation length: derivation_length

production:

O:        #seed
  global germination_offset
  germination_offset = germination_offset - 1
  if germination_offset is 2:
    produce RS

R:        #root
  pass

S:      #shoot
  global germination_offset, idGenerator
  germination_offset = germination_offset - 1
  #print 'Debug in S:',
  #print germination_offset
  if germination_offset is 1:
    if determinate_growth is True:
      timeLeft = determinate_bud_lifespan * steps
    else:
      timeLeft = -1
    id = idGenerator + 1
    idGenerator = id
    produce B(id, -1, 0, 2, 0, timeLeft, 0.0, 0.0)

B(id, successorId, order, status, growthDelay, timeLeft, distanceFromGroundToBase, distanceFromBase):      #bud, timeLeft>0 for active bud with determinate life, timeLeft=0 for active bud to abort, timeLeft<0 for forever active bud. ID starts from 1 (-1 means nil)
  if status is 2:     #apical bud grows a node & internode
    produce /(trunk_roll_angle-90)&(trunk_pitch_angle)I(order,distanceFromGroundToBase,distanceFromBase,0,0.0,0.0)B(id,successorId,order,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase)
  elif status is 3:   #dormant bud comes alive as soon as the rhythmic growth factor is strong
    if growthFactor > growthFactorBranchingThreshold:
      produce B(id,successorId,order,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase)
    else:
      produce B(id,successorId,order,3,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase)
  elif status < 0:   #bud grows into a flower
    produce W
    #note: when order=0 (apical bud) and status < 0, the bud will blossom into a flower
                      #status is 0: bud is suppressed, 1: bud is growing new nodes (note: for status 1, only contextual rule I<B will be applied)

I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius) B(id, successorId, bud_order, 1, growthDelay, timeLeft, distanceFromGroundToBase_b, distanceFromBase_b):        #distanceFromBase measures the distance from the bud B to its parent branching node from which the bud B starts off
  #print 'Trace production I'
  length_norm = 0.0
  if (length < internode_length):
    length_norm = length / internode_length   #float
  #print 'length_norm = ',
  #print length_norm

  aggregate_partial_node_per_step = partial_node_per_step + length_norm
  eff_new_nodes = no_new_nodes_per_step

  #print 'Before: aggregate_partial_node_per_step = ', aggregate_partial_node_per_step

  closeToOne = 0.999999999
  if aggregate_partial_node_per_step >= closeToOne:
    eff_new_nodes =  eff_new_nodes + 1
    aggregate_partial_node_per_step = aggregate_partial_node_per_step - closeToOne

  #print 'eff_new_nodes = ', eff_new_nodes, ' aggregate_partial_node_per_step = ', aggregate_partial_node_per_step, ' total new nodes in this step=', eff_new_nodes+aggregate_partial_node_per_step
  diameter_growth_per_node = growthFactor*diameter_growth_rate/annual_no_new_nodes
  cur_radius = radius+0.5*growthFactor*diameter_growth_rate/steps
  near_bud_radius = 0.5*growthFactor*diameter_growth_rate/steps*aggregate_partial_node_per_step
  #print 'diameter_growth_per_node=', diameter_growth_per_node
  #print 'near_bud_radius=', near_bud_radius
  #print 'cur_radius=', cur_radius
  #negligibleTwigs = 0.1  #don't grow when the twigs are at length <10cm
  branchOut = 0
  #branching_segment_factor = 1.0
  branch_length = trunk_height * numpy.power(branch_length_ratio, order)
  terminalBranchingFlag = False
  global idGenerator
  for i in range(eff_new_nodes):
    cur_distanceFromBase = distanceFromBase+(i+1)*internode_length
    nproduce I(order, distanceFromGroundToBase, cur_distanceFromBase, phyllotaxisPosition, internode_length, cur_radius)

    #-------------- branch out at certain height ------------------
    next_branching_height = branch_length * math.ceil(cur_distanceFromBase/branch_length)
    if branchOut is 1:   #only allow branching out once per step
      branchOut = 2
    elif order < maximumBranchOrder and (cur_distanceFromBase + internode_length > next_branching_height) and (cur_distanceFromBase <= next_branching_height):
      if terminalBranching is False:
        branchOut = 1     #signal node to form active axillary bud
      else:
        branchOut = 2
        terminalBranchingFlag = True
      #print 'Branch out, cur_distanceFromBase=', cur_distanceFromBase, ' cur_distanceFromBase+internode_length=', cur_distanceFromBase+internode_length, ' branching_height=', branching_height
    else:
      branchOut = 2     #signal node to form leaf and dormant axillary bud
    #--------------------------------------------------------------

    nproduce N(order, distanceFromGroundToBase+cur_distanceFromBase, phyllotaxisPosition, branchOut, successorId)
    successorId = idGenerator + 1 + i
    phyllotaxisPosition = (phyllotaxisPosition + phyllotaxis_angle) % 360
    cur_radius = cur_radius - 0.5*diameter_growth_per_node

  #if (aggregate_partial_node_per_step > closeToZero):
  #print 'DEBUG aggreate_partial_node_per_step =', aggregate_partial_node_per_step
  #cur_distanceFromBase = distanceFromBase+internode_length*(eff_new_nodes+aggregate_partial_node_per_step)
  cur_distanceFromBase = distanceFromBase+internode_length*eff_new_nodes  #actual distance will be updated correctly on the next step
  #if bud_order is 0:  #check apical bud position
  #  print 'actual cur_distanceFromBase=', distanceFromBase+internode_length*(eff_new_nodes+aggregate_partial_node_per_step)
  nproduce I(order, distanceFromGroundToBase, cur_distanceFromBase, phyllotaxisPosition, internode_length*aggregate_partial_node_per_step, near_bud_radius)
  if terminalBranching is True and terminalBranchingFlag is True:
    if delayedBranching is True:
      growthDelay = branchingDelay * steps
    produce B(id, successorId, bud_order, 4, growthDelay, timeLeft, distanceFromGroundToBase, cur_distanceFromBase)
  else:
    produce B(id, successorId, bud_order, 1, growthDelay, timeLeft, distanceFromGroundToBase, cur_distanceFromBase)

I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius) > B(id, successorId, bud_order, 0, growthDelay, timeLeft, distanceFromGroundToBase_b, distanceFromBase_b):        #don't grow radius if bud is dormant
  produce I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius)

I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius):        #distanceFromBase measures internode's tip distance to parent branching node
  produce I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius+0.5*growthFactor*diameter_growth_rate/steps)

L(fallen, size, duration):      #leaf
  if fallen is 1 or random.randint(1,10)<3 or duration>leafDieAge*steps:    #node branching out, so shed the leaf; or randomly shed the leaf (wind, rain factors, etc); or when leaf has grown long enough (time to shed in autumn (duration since spring till autumn ~6-9mth, etc.)
    produce *
  else:
    if (size < leafMaxLength):
      size = size + growthFactor*leafGrowthRate/steps
    produce L(fallen, size, duration+1)

W:      #flower
  pass
  #produce *
  #wither
  #produce U

U:      #fruit
  pass
  #produce *
  #fallen

G:      #growth unit
  pass

homomorphism:

#active apical bud - pink
B(id,successorId,0,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase) --> SetColor(6)@O(0.02)

#active first order axillary bud - blue
B(id,successorId,1,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase) --> SetColor(5)@O(0.01)

#active second order axillary bud - green
B(id,successorId,2,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase) --> SetColor(2)@O(0.01)

#active third or higher order axillary bud - yellow
B(id,successorId,order,1,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase) --> SetColor(4)@O(0.005)

#dormant bud - white
B(id,successorId,order,0,growthDelay,timeLeft,distanceFromGroundToBase,distanceFromBase) --> SetColor(0)@O(0.005)

#non-fallen leaf
L(0, size, duration):
  #print 'Trace homomorphism'
  if duration < leafOldAge*steps:  #green leaf
    produce SetColor(2)[&(30)~l(size)]
  else:    #yellow old leaf, falling off soon
    produce Setcolor(4)[&(45)~l(size)]

#flower - red
W --> SetColor(3)@O(0.15)

#I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, 0.0, radius) --> SetColor(0)f(turtle_draw_zero_length_error_prevention, radius)   #necessary drawing for correct mtg generation (mtg skipped zero length drawing, causing skipped index problem)
#I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, 0.0, radius) -->     #draw nothing, enable this line for visualising in L-Py, but disable this when generating mtg?
#I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, 0.0) -->     #draw nothing, enable this line for visualising in L-Py, but disable this when generating mtg?
I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, length, radius) --> SetColor(1)F(length, radius)

decomposition:
N(order, distanceFromGround, phyllotaxisPosition, branchingSignal, successorId):      #node
  no_branches = 1       #default
  if order is 0:
    no_branches = no_first_ord_branches #(int)(math.ceil(growthFactor*no_first_ord_branches)) - note: number of branches is not affected by rhythmic growth factor; it's inherent from the leaf arrangement (alternate/opposite/whorled)
  else:
    no_branches = no_second_ord_branches #(int)(math.ceil(growthFactor*no_second_ord_branches))
  #print 'growthFactor=', growthFactor, ' no_branches=', no_branches
  branch_spacing_angle = 0
  if no_branches > 1:
    branch_spacing_angle = 360/no_branches
  if determinate_growth is True:
    timeLeft = determinate_bud_lifespan * steps
  else:
    timeLeft = -1
  growthDelay = 0
  if delayedBranching is True:
    growthDelay = branchingDelay * steps
  budStatus = 0  #0=dormant
  if branchingSignal is 1:    #branchingSignal = 1 will signal leaf to grow and axillary bud to branch out
    if growthFactor>growthFactorBranchingThreshold and delayedBranching is False:
      budStatus = 1
    #print 'Growth delay!', growthDelay, 'steps, budStatus=', budStatus
  #elif branchingSignal is 2:  #branchingSignal = 2 will signal node to grow leaf and dormant axillary bud
  leafStatus = 1  #1=fallen
  if growthFactor>growthFactorLeafingThreshold:
    leafStatus = 0
  global idGenerator
  id = idGenerator + 1
  idGenerator = id
  for i in range(no_branches):    #node transforms into buds and/or leaves
    nproduce [/(phyllotaxisPosition+branching_roll_angle+(i*branch_spacing_angle)-90)&(branching_pitch_angle)L(leafStatus,0,0)I(order+1,distanceFromGround,0.0,0,0.0,0.0)B(id,successorId,order+1,budStatus,growthDelay,timeLeft,distanceFromGround,0.0)]

I(order, distanceFromGroundToBase_i, distanceFromBase_i, phyllotaxisPosition, length, radius) < B(id, successorId, bud_order, status, growthDelay, timeLeft, distanceFromGroundToBase, distanceFromBase):      #update bud position after internodes grow in "production" phase; determinate growth pattern: stop elongation after a period of time/season
  #print 'Trace decomposition B'
  #print 'Bud order=', bud_order, ' status=', status, 'distance-from-base=', distanceFromGroundToBase_i+distanceFromBase_i
  global wakeupBudPool
  if status is 1:
    if timeLeft > 0:
      produce B(id, successorId, bud_order, 1, growthDelay, timeLeft-1, distanceFromGroundToBase_i, distanceFromBase_i)
    elif timeLeft == 0:
      if sympodialBranching is True:
        #signal nearest axillary bud(s) to branch out
        putBudIntoPool = True
        for b in wakeupBudPool:
          if b == successorId:  #successor bud is already in pool
            putBudIntoPool = False
            break
        if putBudIntoPool is True:
          wakeupBudPool.append(successorId)
          clearPool = False
      if random.randint(1,10) < 8:  #todo: to convert timeLeft to spring season signal (time for bud to blossom into flower)
        produce B(id, successorId, bud_order, -1, growthDelay, 0, distanceFromGroundToBase_i, distanceFromBase_i)
      else:
        produce *
        #produce I(order, distanceFromGroundToBase_i, distanceFromBase_i, phyllotaxisPosition, 0.0, 0.0)
    else: #timeLeft < 0
      #pass
      produce B(id, successorId, bud_order, status, growthDelay, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
  elif status is 0:
    if growthDelay > 1:
      produce B(id, successorId, bud_order, status, growthDelay-1, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
    elif growthDelay == 1:   #it's time for dormant bud to wake up
      produce B(id, successorId, bud_order, 3, 0, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
    else:  #growthDelay <= 0
      if sympodialBranching is True:
        #check if this bud is in the wakeupBudPool, then change the status of the bud to wake up from dormancy
        for b in wakeupBudPool:
          if b == id:
            clearPool = True
            produce B(id, successorId, bud_order, 3, 0, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
        produce B(id, successorId, bud_order, status, 0, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
      else: #remain dormant
        produce B(id, successorId, bud_order, status, 0, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
  elif status is 4:  #allow bud to split into 2 or more for terminal branching
    if growthDelay > 0:
      produce B(id, successorId, bud_order, status, growthDelay-1, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
    elif growthFactor <= growthFactorBranchingThreshold:  #do nothing
      produce B(id, successorId, bud_order, status, 0, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)
    else:  #if growthFactor > growthFactorBranchingThreshold:
      no_branches = no_first_ord_branches
      if bud_order > 0:
        no_branches = no_second_ord_branches
      branch_spacing_angle = 0
      if no_branches > 1:
        branch_spacing_angle = 360/no_branches
      originalTimeLeft = -1
      if determinate_growth is True:
        originalTimeLeft = determinate_bud_lifespan * steps
      for i in range(no_branches):
        nproduce [/(branching_roll_angle+(i*branch_spacing_angle)-90)&(branching_pitch_angle)I(bud_order+1,distanceFromGroundToBase_i+distanceFromBase_i,0.0,0,0.0,0.0)B(id,successorId,bud_order+1,1,growthDelay,originalTimeLeft,distanceFromGroundToBase_i+distanceFromBase_i,0.0)]
  else:
    produce B(id, successorId, bud_order, status, growthDelay, timeLeft, distanceFromGroundToBase_i, distanceFromBase_i)

  #obsolete: the following section use determinate_height to signal bud to abort/flower hence stopping elongation
  #if distanceFromGroundToBase+distanceFromBase > determinate_height: #check for the right condition to terminate apical bud's growth by abortion
  #  if random.randint(1,10) < 8:  #todo: to convert this to time-wise signal for spring season (time for bud to blossom into flower)
  #    produce B(bud_order,-1)
  #  else:
  #    #produce *
  #    produce I(order, distanceFromGroundToBase, distanceFromBase, phyllotaxisPosition, 0.0, 0.0)

#group: 1
#production:
#homomorphism:
#decomposition:
#endgroup  #following rules will be assined to default 0 group unless specified

endlsystem
