import random
import numpy

#initial turtle's orientation: Head Z+ [0,0,1], Up Y+ [0,1,0], Left X+ [1,0,0]
#to align turtle's Right X- [-1,0,0] to Earth's North [0,1,0], rotate the world by -90degrees around Z+ axis, i.e., roll angle offset -90degrees
#order of rotations: roll first, then pitch
#assumption: young branches and leaves never grow until the trunk height at mature phase (in reality, branches and leaves have been falling off at lower trunk segments before matured tree trunk appears smooth)

#Average tree parameters for:
#generic tree: age=10, trunk_pitch_angle=5.0, trunk_height=3.0, no_first_ord_branches=3, no_second_ord_branches=5, branching_pitch_angle=45.0, branching_roll_angle=30.0, diameter_growth_rate=0.1, annual_no_new_nodes=30.0, avg_internode_length=0.03
#)raintree: age=10, trunk_pitch_angle=2.0, trunk_height=2.205, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.619/20, annual_no_new_nodes=28.5, avg_internode_length=0.0589
#)yellow flame: age=11, trunk_pitch_angle=2.0, trunk_height=2.8497, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.4725/11, annual_no_new_nodes=44.148, avg_internode_length=0.03232
#)khaya: age=10, trunk_pitch_angle=0.0, trunk_height=3.872, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.983/10, annual_no_new_nodes=117.231, avg_internode_length=0.02727
#)sterculia: age=4, trunk_pitch_angle=0.0, trunk_height=4.0356, no_first_ord_branches=3, no_second_ord_branches=3, branching_pitch_angle=35.0, branching_roll_angle=120.0, diameter_growth_rate=0.3139/4, annual_no_new_nodes=47.684, avg_internode_length=0.09425
#)palm:age=15, trunk_pitch_angle=5.0, trunk_height=10.0, no_first_ord_branches=10, no_second_ord_branches=0, branching_pitch_angle=10.0, branching_roll_angle=30.0, diameter_growth_rate=0.30/15, annual_no_new_nodes=7.0, avg_internode_length=0.10
#)hopea:age=30, trunk_pitch_angle=0.0, trunk_height=3.0244, no_first_ord_branches=3, no_second_ord_branches=2, branching_pitch_angle=45.0, branching_roll_angle=120.0, diameter_growth_rate=0.3176/30, annual_no_new_nodes=24.0, avg_internode_length=0.02137
#)mahogany:age=20, trunk_pitch_angle=2.0, trunk_height=3.111, no_first_ord_branches=1, no_second_ord_branches=1, branching_pitch_angle=20.0, branching_roll_angle=45.0, diameter_growth_rate=0.476/20, annual_no_new_nodes=26.182, avg_internode_length=0.02584
#)syzygium grande:age=20, trunk_pitch_angle=1.0, trunk_height=4.0438, no_first_ord_branches=3, no_second_ord_branches=3, branching_pitch_angle=20.0, branching_roll_angle=120.0, diameter_growth_rate=0.499/20, annual_no_new_nodes=11.448, avg_internode_length=0.07248
#)tabebuia rosea:age=8, trunk_pitch_angle=0.0, trunk_height=3.265, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=30.0, branching_roll_angle=180.0, diameter_growth_rate=0.4037/8, annual_no_new_nodes=39.333, avg_internode_length=0.04753
#)syzygium myrtifolium:age=20, trunk_pitch_angle=0.0, trunk_height=1.174, no_first_ord_branches=2, no_second_ord_branches=2, branching_pitch_angle=45.0, branching_roll_angle=180.0, diameter_growth_rate=0.10/20, annual_no_new_nodes=12.0, avg_internode_length=0.02358
#
params = numpy.loadtxt("/home/daniel-wise/Dropbox/Work/codes/python/vs1/source/optimisation/current_opt.txt",delimiter='\t',usecols=(0,1,2,3,4,5,6,7,8,9,10))
age = int(params[0])
trunk_pitch_angle = params[1]           #pitch down wrt turtle's left, in degrees
trunk_roll_angle = params[2]         #roll left wrt turtle's head, in degrees
trunk_height = params[3]              #unit: m, trunk's actual length (regardless of orientation wrt ground) - whn the trunk reach this height, it will signal the tree to branch out for the first time
no_first_ord_branches = int(params[4])         #number of first order branches
no_second_ord_branches = int(params[5])        #number of second order branches (assume uniformity)
branching_pitch_angle = params[6]
branching_roll_angle = params[7]
diameter_growth_rate = params[8]/age  #m/year? relative growth rate?
annual_no_new_nodes = params[9]    #number of new buds per year
avg_internode_length = params[10]    #unit: m

apical_determinate = False         #flag of determinate or indeterminate growth for apical bud
lateral_determinate = False        #flag of determinate or indeterminate growth for lateral bud
bud_lifespan = 5                  #lifespan of a bud before it abort or transform into flower

steps = 8 #int(annual_no_new_nodes)       #timestep: 'steps' steps/year). Branching signal relay will delay branching out if steps < annual_no_new_nodes
germination_offset = 10     #number of initial derivation to account for germination before visual growth of internode starts (i.e., before time t starts)
phyllotaxis_angle = 0
phyllotaxis_increment = 30
partial_node_per_step = (float)(annual_no_new_nodes%steps)/steps
no_new_nodes_per_step = int(annual_no_new_nodes // steps)  #integer
turtle_draw_zero_length_error_prevention = 0.0000000001
#determinate_height = 30.0
determinate_bud_lifespan = bud_lifespan * steps    #x * steps means annual life cycle (the bud will turn to flower in x yrs); trees are either annual(x=1), biennial(x=2), or perennial(x>2)
derivation_length = germination_offset + age*steps

#print 'partial_node_per_step=', partial_node_per_step
#print 'no_new_nodes_per_step=', no_new_nodes_per_step
print 'Derivation length:', derivation_length

derivation length: derivation_length

module O    #seed
module S    #shoot
module R    #root
module B    #bud
module N    #node
module I    #internode
module L    #leaf
module W    #flower
module U    #fruit

Axiom: O

def EndEach(lstring):
  #pass
  #print 'Current lstring:', lstring
  print 'Derivation progress:', getIterationNb()+1, ' / ', derivation_length

production:

O:        #seed
  global germination_offset
  germination_offset = germination_offset - 1
  if germination_offset is 2:
    produce RS

R:        #root
  pass

S:      #shoot
  global germination_offset
  germination_offset = germination_offset - 1
  #print 'Debug in S:',
  #print germination_offset
  if germination_offset is 1:
    if apical_determinate is True:
      timeLeft = determinate_bud_lifespan
    else:
      timeLeft = -1
    produce B(0,2,timeLeft)

#group 1:    #rules for determinate terminal meristem growth pattern
I(order, distanceFromGroundToBase, distanceFromBase, length, radius) < B(bud_order, 1, timeLeft):      #determinate growth pattern: stop elongation after a period of time/season
  if timeLeft > 0:
    produce B(bud_order, 1, timeLeft-1)
  elif timeLeft == 0:
    if random.randint(1,10) < 8:  #todo: to convert timeLeft to spring season signal (time for bud to blossom into flower)
      produce B(bud_order,-1,0)
    else:
      #produce *
      produce I(order, distanceFromGroundToBase, distanceFromBase, 0.0, 0.0)
  #else: #timeLeft < 0
    #pass

  #obsolete: the following section use determinate_height to signal bud to abort/flower hence stopping elongation
  #if distanceFromGroundToBase+distanceFromBase > determinate_height: #check for the right condition to terminate apical bud's growth by abortion
  #  if random.randint(1,10) < 8:  #todo: to convert this to time-wise signal for spring season (time for bud to blossom into flower)
  #    produce B(bud_order,-1)
  #  else:
  #    #produce *
  #    produce I(order, distanceFromGroundToBase, distanceFromBase, 0.0, 0.0)
#endgroup

B(order, status, timeLeft):      #bud, timeLeft>0 for active bud with determinate life, timeLeft=0 for active bud to abort, timeLeft<0 for forever active bud
  if status is 2:     #apical bud grows a node & internode
    produce /(trunk_roll_angle-90)&(trunk_pitch_angle)I(0,0.0,0.0,0.0,0.0)I(0,0.0,0.0,0.0,0.0)B(0,1,timeLeft)
  elif status is 3:   #dormant bud comes alive
    produce B(order,1,timeLeft)
  elif status < 0:   #bud grows into a flower
    produce W
    #note: when order=0 (apical bud) and status < 0, the bud will blossom into a flower
                      #status is 0: bud is suppressed, 1: bud is growing new nodes (note: for status 1, only contextual rule I<B will be applied)

N(order, distanceFromGround, branchingSignal):      #node
  no_branches = 1       #default
  if order is 0:
    no_branches = no_first_ord_branches
  else:
    no_branches = no_second_ord_branches
  if lateral_determinate is True:
    timeLeft = determinate_bud_lifespan
  else:
    timeLeft = -1
  if branchingSignal is 1:    #branchingSignal = 1 will signal axillary bud to branch out
    for i in range(no_branches):    #node transforms into buds and/or leaves
      nproduce [/((i+1)*branching_roll_angle-90)&(branching_pitch_angle)L(1,0)I(order+1,distanceFromGround,0.0,0.0,0.0)B(order+1,1,timeLeft)]
  elif branchingSignal is 2:  #branchingSignal = 2 will signal node to grow leaf and dormant axillary bud
    for i in range(no_branches):    #node transforms into buds and/or leaves
      nproduce [/((i+1)*branching_roll_angle-90)&(branching_pitch_angle)L(0,0)I(order+1,distanceFromGround,0.0,0.0,0.0)B(order+1,0,timeLeft)]

I(order, distanceFromGroundToBase, distanceFromBase, length, radius) > B(bud_order, 1, timeLeft):        #distanceFromBase measures the distance from the bud B to its parent branching node from which the bud B starts off
  length_norm = 0.0
  if (length < avg_internode_length):
    length_norm = length / avg_internode_length   #float
  #print 'length_norm = ',
  #print length_norm

  aggregate_partial_node_per_step = partial_node_per_step + length_norm
  eff_new_nodes = no_new_nodes_per_step

  if aggregate_partial_node_per_step >= 1:
    eff_new_nodes =  eff_new_nodes + 1
    aggregate_partial_node_per_step = aggregate_partial_node_per_step - 1

  #print 'aggregate_partial_node_per_step = ',
  #print aggregate_partial_node_per_step

  diameter_growth_per_node = diameter_growth_rate/annual_no_new_nodes
  cur_radius = radius+0.5*diameter_growth_rate/steps
  near_bud_radius = 0.5*diameter_growth_rate/steps*aggregate_partial_node_per_step
  #print 'diameter_growth_per_node=', diameter_growth_per_node
  #print 'near_bud_radius=', near_bud_radius
  #print 'cur_radius=', cur_radius
  if eff_new_nodes>=1:
    branchOut = 0
    for i in range(eff_new_nodes):
      cur_distanceFromBase = distanceFromBase+i*avg_internode_length
      #print 'cur_distanceFromBase,trunk_height,avg_internode_length=',
      #print cur_distanceFromBase, trunk_height, avg_internode_length, cur_distanceFromBase>=trunk_height, cur_distanceFromBase<trunk_height+avg_internode_length
      #if (cur_distanceFromBase is trunk_height or cur_distanceFromBase > trunk_height) and (cur_distanceFromBase < trunk_height+avg_internode_length):
      #if (numpy.isclose(cur_distanceFromBase, trunk_height, rtol=1e-8, atol=1e-3) or cur_distanceFromBase > trunk_height) and (cur_distanceFromBase < trunk_height+avg_internode_length):
      if branchOut is 1:   #only allow branching out once per step
        branchOut = 2
      elif (cur_distanceFromBase > trunk_height) and (cur_distanceFromBase - 1.000001*avg_internode_length < trunk_height):
        branchOut = 1     #signal node to form active axillary bud
      else: #elif i==eff_new_nodes-1:
        branchOut = 2     #signal node to form leaf and dormant axillary bud

      nproduce I(order, distanceFromGroundToBase, cur_distanceFromBase, avg_internode_length, cur_radius)N(order, distanceFromGroundToBase+cur_distanceFromBase, branchOut)
      cur_radius = cur_radius - 0.5*diameter_growth_per_node
  produce I(order, distanceFromGroundToBase, distanceFromBase+avg_internode_length*(eff_new_nodes+aggregate_partial_node_per_step), avg_internode_length*aggregate_partial_node_per_step, near_bud_radius)

I(order, distanceFromGroundToBase, distanceFromBase, length, radius) > B(bud_order, 0, timeLeft):        #don't grow radius if bud is dormant
  produce I(order, distanceFromGroundToBase, distanceFromBase, length, radius)

I(order, distanceFromGroundToBase, distanceFromBase, length, radius):        #distanceFromBase measures internode's tip distance to parent branching node
  produce I(order, distanceFromGroundToBase, distanceFromBase, length, radius+0.5*diameter_growth_rate/steps)


L(fallen, duration):      #leaf
  if fallen is 1 or random.randint(1,10)<3 or duration>20.0*steps:    #node branching out, so shed the leaf; or randomly (50% likelihood) shed the leaf
    produce *
  else:
    produce L(fallen, duration+1)

W:      #flower
  pass
  #produce *
  #wither
  #produce U

U:      #fruit
  pass
  #produce *
  #fallen

homomorphism:
B(0,1,timeLeft) --> SetColor(6)@O(0.02)      #active apical bud - pink
B(order,1,timeLeft) --> SetColor(5)@O(0.02)  #active axillary bud - blue
B(order,0,timeLeft) --> SetColor(0)@O(0.01)  #dormant bud - white
L(fallen, duration):
  global phyllotaxis_angle
  phyllotaxis_angle = (phyllotaxis_angle + phyllotaxis_increment) % 360
  oldage = 3.0*steps
  if duration < oldage:  #green leaf
    #produce SetColor(2)[/(phyllotaxis_angle)&(45)@b(0.1+0.05*duration/oldage,0)]
    produce SetColor(2)[/(phyllotaxis_angle)&(130)~l(0.3)]
    #produce SetColor(2)[/(phyllotaxis_angle)&(45)~l(3.0)]  #for palm
  else:    #yellow old leaf, falling off soon
    #produce Setcolor(4)[/(phyllotaxis_angle)&(60)@b(0.15,0)]
    produce Setcolor(4)[/(phyllotaxis_angle)&(180)~l(0.3)]
    #produce SetColor(2)[/(phyllotaxis_angle)&(120)~l(3.0)]  #for palm
W --> SetColor(3)@O(0.25)    #flower - red
I(order, distanceFromGroundToBase, distanceFromBase, 0.0, radius) --> SetColor(0)F(turtle_draw_zero_length_error_prevention, radius)   #necessary drawing for correct mtg generation (mtg skipped zero length drawing, causing skipped index problem)
#I(order, distanceFromGroundToBase, distanceFromBase, 0.0, radius) -->     #draw nothing, enable this line for visualising in L-Py, but disable this when generating mtg
I(order, distanceFromGroundToBase, distanceFromBase, length, radius) --> SetColor(1)F(length, radius)

endlsystem
